--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -2556,6 +2556,7 @@ enum netdev_cmd {
 	NETDEV_CVLAN_FILTER_DROP_INFO,
 	NETDEV_SVLAN_FILTER_PUSH_INFO,
 	NETDEV_SVLAN_FILTER_DROP_INFO,
+	NETDEV_DEAD,
 };
 const char *netdev_cmd_to_name(enum netdev_cmd cmd);
 
--- a/include/net/fib_rules.h
+++ b/include/net/fib_rules.h
@@ -54,6 +54,7 @@ struct fib_lookup_arg {
 	int			flags;
 #define FIB_LOOKUP_NOREF		1
 #define FIB_LOOKUP_IGNORE_LINKSTATE	2
+#define FIB_LOOKUP_IGNORE_DEAD      4
 };
 
 struct fib_rules_ops {
--- a/include/net/ip6_route.h
+++ b/include/net/ip6_route.h
@@ -37,6 +37,7 @@ struct route_info {
 #define RT6_LOOKUP_F_SRCPREF_COA	0x00000020
 #define RT6_LOOKUP_F_IGNORE_LINKSTATE	0x00000040
 #define RT6_LOOKUP_F_DST_NOREF		0x00000080
+#define RT6_LOOKUP_F_IGNORE_DEAD	0x00000100
 
 /* We do not (yet ?) support IPv6 jumbograms (RFC 2675)
  * Unlike IPv4, hdr->seg_len doesn't include the IPv6 header
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -1536,7 +1536,7 @@ const char *netdev_cmd_to_name(enum netd
 	N(UDP_TUNNEL_DROP_INFO) N(CHANGE_TX_QUEUE_LEN)
 	N(CVLAN_FILTER_PUSH_INFO) N(CVLAN_FILTER_DROP_INFO)
 	N(SVLAN_FILTER_PUSH_INFO) N(SVLAN_FILTER_DROP_INFO)
-	N(PRE_CHANGEADDR)
+	N(PRE_CHANGEADDR) N(DEAD)
 	}
 #undef N
 	return "UNKNOWN_NETDEV_EVENT";
--- a/net/ipv4/fib_semantics.c
+++ b/net/ipv4/fib_semantics.c
@@ -2084,6 +2084,9 @@ int fib_sync_down_dev(struct net_device
 				case NETDEV_CHANGE:
 					nexthop_nh->fib_nh_flags |= RTNH_F_LINKDOWN;
 					break;
+				case NETDEV_DEAD:
+					nexthop_nh->fib_nh_flags |= RTNH_F_DEAD;
+					break;
 				}
 				call_fib_nh_notifiers(nexthop_nh,
 						      FIB_EVENT_NH_DEL);
@@ -2110,6 +2113,9 @@ int fib_sync_down_dev(struct net_device
 			case NETDEV_CHANGE:
 				fi->fib_flags |= RTNH_F_LINKDOWN;
 				break;
+			case NETDEV_DEAD:
+				fi->fib_flags |= RTNH_F_DEAD;
+				break;
 			}
 			ret++;
 		}
@@ -2119,6 +2125,7 @@ int fib_sync_down_dev(struct net_device
 
 	return ret;
 }
+EXPORT_SYMBOL(fib_sync_down_dev);
 
 /* Must be invoked inside of an RCU protected region.  */
 void fib_select_default(const struct flowi4 *flp, struct fib_result *res)
@@ -2265,7 +2272,7 @@ repeat:
 
 				rcu_read_lock();
 				if (fib_lookup(dev_net(dev), &fl4, &res,
-					FIB_LOOKUP_IGNORE_LINKSTATE) != 0) {
+					FIB_LOOKUP_IGNORE_LINKSTATE | FIB_LOOKUP_IGNORE_DEAD) != 0) {
 					rcu_read_unlock();
 					continue;
 				}
@@ -2295,6 +2302,7 @@ repeat:
 
 	return ret;
 }
+EXPORT_SYMBOL(fib_sync_up);
 
 #ifdef CONFIG_IP_ROUTE_MULTIPATH
 static bool fib_good_nh(const struct fib_nh *nh)
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@ -1462,7 +1462,7 @@ out_reject:
 			trace_fib_table_lookup(tb->tb_id, flp, NULL, err);
 			return err;
 		}
-		if (fi->fib_flags & RTNH_F_DEAD)
+		if (!(fib_flags & FIB_LOOKUP_IGNORE_DEAD) && (fi->fib_flags & RTNH_F_DEAD))
 			continue;
 
 		if (unlikely(fi->nh && nexthop_is_blackhole(fi->nh))) {
@@ -1473,7 +1473,7 @@ out_reject:
 		for (nhsel = 0; nhsel < fib_info_num_path(fi); nhsel++) {
 			struct fib_nh_common *nhc = fib_info_nhc(fi, nhsel);
 
-			if (nhc->nhc_flags & RTNH_F_DEAD)
+			if (!(fib_flags & FIB_LOOKUP_IGNORE_DEAD) && (nhc->nhc_flags & RTNH_F_DEAD))
 				continue;
 			if (ip_ignore_linkdown(nhc->nhc_dev) &&
 			    nhc->nhc_flags & RTNH_F_LINKDOWN &&
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -761,7 +761,7 @@ static bool find_match(struct fib6_nh *n
 	bool rc = false;
 	int m;
 
-	if (nh->fib_nh_flags & RTNH_F_DEAD)
+	if (!(strict & RT6_LOOKUP_F_IGNORE_DEAD) && (nh->fib_nh_flags & RTNH_F_DEAD))
 		goto out;
 
 	if (ip6_ignore_linkdown(nh->fib_nh_dev) &&
@@ -2239,6 +2239,7 @@ redo_rt6_select:
 
 	return 0;
 }
+EXPORT_SYMBOL(fib6_table_lookup);
 
 struct rt6_info *ip6_pol_route(struct net *net, struct fib6_table *table,
 			       int oif, struct flowi6 *fl6,
@@ -4723,6 +4724,7 @@ void rt6_sync_up(struct net_device *dev,
 
 	fib6_clean_all(dev_net(dev), fib6_ifup, &arg);
 }
+EXPORT_SYMBOL(rt6_sync_up);
 
 /* only called for fib entries with inline fib6_nh */
 static bool rt6_multipath_uses_dev(const struct fib6_info *rt,
@@ -4817,6 +4819,13 @@ static int fib6_ifdown(struct fib6_info
 		rt->fib6_nh->fib_nh_flags |= RTNH_F_LINKDOWN;
 		rt6_multipath_rebalance(rt);
 		break;
+	case NETDEV_DEAD:
+		if (rt->fib6_nh->fib_nh_dev != dev ||
+		    rt->fib6_flags & (RTF_LOCAL | RTF_ANYCAST))
+			break;
+		rt->fib6_nh->fib_nh_flags |= RTNH_F_DEAD;
+		rt6_multipath_rebalance(rt);
+		break;
 	}
 
 	return 0;
@@ -4837,6 +4846,7 @@ void rt6_sync_down_dev(struct net_device
 	else
 		fib6_clean_all(net, fib6_ifdown, &arg);
 }
+EXPORT_SYMBOL(rt6_sync_down_dev);
 
 void rt6_disable_ip(struct net_device *dev, unsigned long event)
 {
